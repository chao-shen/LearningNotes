# GC机制
## 如何判断对象是否可以被回收
* 引用计数法

    引用计数法思路是这样的，给对象添加一个引用计数器，有地方引用时，计数器就加1；当引用失效时就减1；当计数为0的时候就判定对象需要被回收

    引用计数法有一个难以解决的问题就是相互循环引用问题。

    例：

    obj1.instance=obj2.instance;

    obj2.instance=obj1.instance;

* 可达性分析算法

  通过称为“GC Roots”的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象需要被回收.

    Java可作为GC Roots的对象包括下面几种：

    * 虚拟机栈中引用的对象

    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI引用的对象

## 垃圾收集算法
* 标记-清除算法
* 复制算法
* 标记-整理算法（和标记-清除算法不同的是，标记-整理算法在标记后不直接清理可回收内存，而是将存活对象都移动到一端，然后清除掉可回收内存）
* 分代收集算法

### 分代收集算法
![image](https://img-blog.csdnimg.cn/20191021230952436.png "")

JVM将堆进行分代，一般分为两部分
年轻代、老年代

#### 一个完整的GC流程
新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from，复制的时候，如果Survivor to无法容纳全部存活的对象，则根据老年代分配担保将对象copy进入老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）

#### 注意，如下几种情况比较特殊，需要注意

1.大对象直接进入老年代，JVM中有个参数配置-XX：PretenureSizeThreshold，令大于这个设置值得对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制

2.长期存活的对象进入老年代，JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设置为1，每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenringTheshold来设定），就会移入老年代

3.JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等待最大年龄要求

4.新老代就是用复制算法，是因为新生代的对象大部分存活时间不长，所以每次GC的时候复制的比较少，效率高，每次就复制一点点对象到Survivor。

5.老年代用标记-整理算法，老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，GC时移动少量存活对象，不会产生内存碎片。

# 备注
[Java虚拟机 —— 垃圾回收机制](https://juejin.im/post/59c4dd2c5188257e705338cb)

[谈谈你对JVM垃圾收集器算法的了解](https://juejin.im/post/5cc442cd6fb9a032265103e1)